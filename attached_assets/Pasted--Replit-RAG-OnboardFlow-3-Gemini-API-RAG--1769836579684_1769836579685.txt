# ğŸ¤– Replit ì—ì´ì „íŠ¸ë¥¼ ìœ„í•œ RAG ì±—ë´‡ í†µí•© ê°€ì´ë“œ

## ğŸ“‹ í”„ë¡œì íŠ¸ ê°œìš”

OnboardFlow-3 í”„ë¡œì íŠ¸ì— Gemini API ê¸°ë°˜ RAG ì±—ë´‡ì„ í†µí•©í•©ë‹ˆë‹¤.
- **ìœ„ì¹˜**: ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜ì´ì§€ ì˜¤ë¥¸ìª½ í•˜ë‹¨
- **í˜•íƒœ**: í”Œë¡œíŒ… ì±—ë´‡ ì•„ì´ì½˜ + ëª¨ë‹¬ ì±„íŒ…ì°½
- **ê¸°ëŠ¥**: ì—…ë¡œë“œëœ ë§¤ë‰´ì–¼(PDF/Word)ì„ í•™ìŠµí•˜ì—¬ ì§ˆì˜ì‘ë‹µ

---

## ğŸ¯ êµ¬í˜„ ë‹¨ê³„

### STEP 1: íŒ¨í‚¤ì§€ ì„¤ì¹˜

```bash
npm install @google/generative-ai pdf-parse mammoth multer
npm install --save-dev @types/multer @types/pdf-parse
```

---

### STEP 2: ì„œë²„ íŒŒì¼ ìƒì„±

#### ğŸ“„ `server/services/ragService.ts` ìƒì„±

```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';
import pdfParse from 'pdf-parse';
import mammoth from 'mammoth';
import fs from 'fs/promises';

// ë²¡í„° ìœ ì‚¬ë„ ê³„ì‚°
function cosineSimilarity(vecA: number[], vecB: number[]): number {
  const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
  return dotProduct / (magnitudeA * magnitudeB);
}

// í…ìŠ¤íŠ¸ë¥¼ ì²­í¬ë¡œ ë¶„í• 
function chunkText(text: string, chunkSize: number = 1000, overlap: number = 200): string[] {
  const chunks: string[] = [];
  let start = 0;
  
  while (start < text.length) {
    const end = Math.min(start + chunkSize, text.length);
    chunks.push(text.slice(start, end));
    start += chunkSize - overlap;
  }
  
  return chunks;
}

interface DocumentChunk {
  text: string;
  embedding: number[];
  metadata: {
    filename: string;
    chunkIndex: number;
    totalChunks: number;
  };
}

export class RAGService {
  private genAI: GoogleGenerativeAI;
  private documentChunks: DocumentChunk[] = [];
  private embeddingModel: any;
  private chatModel: any;
  private isInitialized: boolean = false;

  constructor() {
    // ì´ˆê¸°ì—ëŠ” ë¹ˆ ìƒì„±ì
  }

  // API í‚¤ë¡œ ì´ˆê¸°í™”
  async initialize(apiKey: string): Promise<void> {
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.embeddingModel = this.genAI.getGenerativeModel({ model: 'embedding-001' });
    this.chatModel = this.genAI.getGenerativeModel({ 
      model: 'gemini-1.5-flash',
      generationConfig: {
        temperature: 0.7,
        maxOutputTokens: 2048,
      }
    });
    this.isInitialized = true;
  }

  // PDF íŒŒì¼ ì²˜ë¦¬
  async processPDF(filePath: string): Promise<string> {
    try {
      const dataBuffer = await fs.readFile(filePath);
      const pdfData = await pdfParse(dataBuffer);
      
      let text = pdfData.text;
      
      if (pdfData.numpages > 0) {
        text += `\n\n[ì´ ë¬¸ì„œëŠ” ${pdfData.numpages}í˜ì´ì§€ë¡œ êµ¬ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.]`;
      }
      
      return text;
    } catch (error) {
      console.error('PDF ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      throw new Error('PDF íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }

  // Word íŒŒì¼ ì²˜ë¦¬
  async processWord(filePath: string): Promise<string> {
    try {
      const result = await mammoth.extractRawText({ path: filePath });
      return result.value;
    } catch (error) {
      console.error('Word íŒŒì¼ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      throw new Error('Word íŒŒì¼ì„ ì²˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }

  // ë¬¸ì„œ ì¸ë±ì‹±
  async indexDocument(filePath: string, filename: string): Promise<void> {
    if (!this.isInitialized) {
      throw new Error('RAG ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }

    let text: string;
    
    if (filename.toLowerCase().endsWith('.pdf')) {
      text = await this.processPDF(filePath);
    } else if (filename.toLowerCase().endsWith('.docx') || filename.toLowerCase().endsWith('.doc')) {
      text = await this.processWord(filePath);
    } else {
      throw new Error('ì§€ì›í•˜ì§€ ì•ŠëŠ” íŒŒì¼ í˜•ì‹ì…ë‹ˆë‹¤.');
    }

    const chunks = chunkText(text);
    console.log(`${filename}: ${chunks.length}ê°œì˜ ì²­í¬ë¡œ ë¶„í• ë¨`);

    for (let i = 0; i < chunks.length; i++) {
      try {
        const result = await this.embeddingModel.embedContent(chunks[i]);
        const embedding = result.embedding.values;

        this.documentChunks.push({
          text: chunks[i],
          embedding: embedding,
          metadata: {
            filename,
            chunkIndex: i,
            totalChunks: chunks.length
          }
        });

        if (i < chunks.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      } catch (error) {
        console.error(`ì²­í¬ ${i} ì„ë² ë”© ì˜¤ë¥˜:`, error);
      }
    }

    console.log(`${filename} ì¸ë±ì‹± ì™„ë£Œ: ì´ ${this.documentChunks.length}ê°œ ì²­í¬`);
  }

  // ì§ˆë¬¸ì— ê°€ì¥ ê´€ë ¨ìˆëŠ” ì²­í¬ ì°¾ê¸°
  async findRelevantChunks(query: string, topK: number = 5): Promise<DocumentChunk[]> {
    if (!this.isInitialized) {
      throw new Error('RAG ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }

    const result = await this.embeddingModel.embedContent(query);
    const queryEmbedding = result.embedding.values;

    const similarities = this.documentChunks.map(chunk => ({
      chunk,
      similarity: cosineSimilarity(queryEmbedding, chunk.embedding)
    }));

    return similarities
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, topK)
      .map(item => item.chunk);
  }

  // RAGë¥¼ ì‚¬ìš©í•œ ë‹µë³€ ìƒì„±
  async generateAnswer(question: string): Promise<{
    answer: string;
    sources: Array<{ filename: string; chunkIndex: number }>;
  }> {
    if (!this.isInitialized) {
      throw new Error('RAG ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    }

    if (this.documentChunks.length === 0) {
      return {
        answer: 'ì•„ì§ ì¸ë±ì‹±ëœ ë§¤ë‰´ì–¼ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë§¤ë‰´ì–¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”.',
        sources: []
      };
    }

    const relevantChunks = await this.findRelevantChunks(question, 5);

    const context = relevantChunks
      .map((chunk, idx) => `[ë¬¸ì„œ ${idx + 1}: ${chunk.metadata.filename}]\n${chunk.text}`)
      .join('\n\n---\n\n');

    const prompt = `ë‹¹ì‹ ì€ ë§¤ë‰´ì–¼ ë¬¸ì„œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì§ˆë¬¸ì— ë‹µí•˜ëŠ” ë„ìš°ë¯¸ì…ë‹ˆë‹¤.

ë‹¤ìŒì€ ê´€ë ¨ ë¬¸ì„œ ë‚´ìš©ì…ë‹ˆë‹¤:

${context}

---

ìœ„ ë¬¸ì„œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µë³€í•´ì£¼ì„¸ìš”. ë¬¸ì„œì— ì—†ëŠ” ë‚´ìš©ì€ ì¶”ì¸¡í•˜ì§€ ë§ê³ , ë¬¸ì„œì— ìˆëŠ” ì •ë³´ë§Œ ì‚¬ìš©í•˜ì—¬ ë‹µë³€í•˜ì„¸ìš”.

ì§ˆë¬¸: ${question}

ë‹µë³€:`;

    try {
      const result = await this.chatModel.generateContent(prompt);
      const answer = result.response.text();

      return {
        answer,
        sources: relevantChunks.map(chunk => ({
          filename: chunk.metadata.filename,
          chunkIndex: chunk.metadata.chunkIndex
        }))
      };
    } catch (error) {
      console.error('ë‹µë³€ ìƒì„± ì˜¤ë¥˜:', error);
      throw new Error('ë‹µë³€ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
  }

  // ì¸ë±ì‹±ëœ ë¬¸ì„œ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
  getIndexedDocuments(): Array<{ filename: string; chunks: number }> {
    const docMap = new Map<string, number>();
    
    this.documentChunks.forEach(chunk => {
      const filename = chunk.metadata.filename;
      docMap.set(filename, (docMap.get(filename) || 0) + 1);
    });

    return Array.from(docMap.entries()).map(([filename, chunks]) => ({
      filename,
      chunks
    }));
  }

  // íŠ¹ì • ë¬¸ì„œ ì œê±°
  removeDocument(filename: string): void {
    this.documentChunks = this.documentChunks.filter(
      chunk => chunk.metadata.filename !== filename
    );
  }

  // ëª¨ë“  ë¬¸ì„œ ì œê±°
  clearAll(): void {
    this.documentChunks = [];
  }
}

// ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
export const ragService = new RAGService();
```

---

#### ğŸ“„ `server/routes/rag.ts` ìƒì„±

```typescript
import express, { Request, Response } from 'express';
import multer from 'multer';
import path from 'path';
import fs from 'fs/promises';
import { ragService } from '../services/ragService';

const router = express.Router();

// Multer ì„¤ì •
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads', 'manuals');
    try {
      await fs.mkdir(uploadDir, { recursive: true });
      cb(null, uploadDir);
    } catch (error) {
      cb(error as Error, uploadDir);
    }
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + '-' + file.originalname);
  }
});

const upload = multer({
  storage: storage,
  fileFilter: (req, file, cb) => {
    const ext = path.extname(file.originalname).toLowerCase();
    if (ext === '.pdf' || ext === '.docx' || ext === '.doc') {
      cb(null, true);
    } else {
      cb(new Error('PDF ë˜ëŠ” Word íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.'));
    }
  },
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  }
});

// API í‚¤ ì„¤ì •
router.post('/api/rag/setup', async (req: Request, res: Response) => {
  try {
    const { apiKey } = req.body;
    
    if (!apiKey) {
      return res.status(400).json({ error: 'API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.' });
    }

    await ragService.initialize(apiKey);
    res.json({ message: 'RAG ì‹œìŠ¤í…œì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.' });
  } catch (error) {
    console.error('RAG ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
    res.status(500).json({ error: 'RAG ì‹œìŠ¤í…œ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' });
  }
});

// ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ê¸°ì¡´ íŒŒì¼ ì¸ë±ì‹±
router.post('/api/rag/index-existing', async (req: Request, res: Response) => {
  try {
    const { filePath, filename } = req.body;
    
    if (!filePath || !filename) {
      return res.status(400).json({ error: 'íŒŒì¼ ê²½ë¡œì™€ ì´ë¦„ì´ í•„ìš”í•©ë‹ˆë‹¤.' });
    }

    await ragService.indexDocument(filePath, filename);

    res.json({
      message: 'ë¬¸ì„œê°€ ì„±ê³µì ìœ¼ë¡œ ì¸ë±ì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.',
      filename: filename,
      documents: ragService.getIndexedDocuments()
    });
  } catch (error) {
    console.error('ë¬¸ì„œ ì¸ë±ì‹± ì˜¤ë¥˜:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'ë¬¸ì„œ ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' 
    });
  }
});

// ìƒˆ ë¬¸ì„œ ì—…ë¡œë“œ ë° ì¸ë±ì‹±
router.post('/api/rag/upload', upload.single('file'), async (req: Request, res: Response) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'íŒŒì¼ì´ ì—…ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.' });
    }

    const filePath = req.file.path;
    const filename = req.file.originalname;

    await ragService.indexDocument(filePath, filename);

    res.json({
      message: 'ë¬¸ì„œê°€ ì„±ê³µì ìœ¼ë¡œ ì¸ë±ì‹±ë˜ì—ˆìŠµë‹ˆë‹¤.',
      filename: filename,
      documents: ragService.getIndexedDocuments()
    });
  } catch (error) {
    console.error('ë¬¸ì„œ ì—…ë¡œë“œ ì˜¤ë¥˜:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'ë¬¸ì„œ ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' 
    });
  }
});

// ì§ˆë¬¸í•˜ê¸°
router.post('/api/rag/ask', async (req: Request, res: Response) => {
  try {
    const { question } = req.body;

    if (!question) {
      return res.status(400).json({ error: 'ì§ˆë¬¸ì´ í•„ìš”í•©ë‹ˆë‹¤.' });
    }

    const result = await ragService.generateAnswer(question);

    res.json({
      answer: result.answer,
      sources: result.sources
    });
  } catch (error) {
    console.error('ì§ˆë¬¸ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
    res.status(500).json({ 
      error: error instanceof Error ? error.message : 'ë‹µë³€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' 
    });
  }
});

// ì¸ë±ì‹±ëœ ë¬¸ì„œ ëª©ë¡ ì¡°íšŒ
router.get('/api/rag/documents', (req: Request, res: Response) => {
  try {
    const documents = ragService.getIndexedDocuments();
    res.json({ documents });
  } catch (error) {
    console.error('ë¬¸ì„œ ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
    res.status(500).json({ error: 'ë¬¸ì„œ ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' });
  }
});

// íŠ¹ì • ë¬¸ì„œ ì œê±°
router.delete('/api/rag/documents/:filename', (req: Request, res: Response) => {
  try {
    const { filename } = req.params;
    ragService.removeDocument(decodeURIComponent(filename));

    res.json({ 
      message: 'ë¬¸ì„œê°€ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤.',
      documents: ragService.getIndexedDocuments()
    });
  } catch (error) {
    console.error('ë¬¸ì„œ ì œê±° ì˜¤ë¥˜:', error);
    res.status(500).json({ error: 'ë¬¸ì„œ ì œê±°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' });
  }
});

export default router;
```

---

### STEP 3: ì„œë²„ì— ë¼ìš°íŠ¸ ì¶”ê°€

#### ğŸ“ `server/index.ts` ìˆ˜ì • (ê¸°ì¡´ íŒŒì¼ì— ì¶”ê°€)

```typescript
// ê¸°ì¡´ imports...
import ragRoutes from './routes/rag';

// ê¸°ì¡´ ë¯¸ë“¤ì›¨ì–´ ì„¤ì •...

// RAG ë¼ìš°íŠ¸ ì¶”ê°€ (ë‹¤ë¥¸ ë¼ìš°íŠ¸ë“¤ê³¼ í•¨ê»˜)
app.use(ragRoutes);

// ë‚˜ë¨¸ì§€ ì½”ë“œ...
```

---

### STEP 4: í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸ ìƒì„±

#### ğŸ“„ `client/src/components/ChatbotModal.tsx` ìƒì„±

```typescript
import React, { useState, useEffect, useRef } from 'react';
import { X, Send, MessageCircle, Loader2, FileText } from 'lucide-react';

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  sources?: Array<{ filename: string; chunkIndex: number }>;
  timestamp: Date;
}

interface ChatbotModalProps {
  isOpen: boolean;
  onClose: () => void;
  apiKey: string;
  onApiKeyRequired: () => void;
}

export default function ChatbotModal({ isOpen, onClose, apiKey, onApiKeyRequired }: ChatbotModalProps) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputMessage, setInputMessage] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [indexedDocs, setIndexedDocs] = useState<Array<{ filename: string; chunks: number }>>([]);
  
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  // ëª¨ë‹¬ì´ ì—´ë¦´ ë•Œ í¬ì»¤ìŠ¤
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen]);

  // ë©”ì‹œì§€ ìŠ¤í¬ë¡¤
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // ì¸ë±ì‹±ëœ ë¬¸ì„œ ë¡œë“œ
  useEffect(() => {
    if (isOpen && apiKey) {
      loadIndexedDocuments();
    }
  }, [isOpen, apiKey]);

  const loadIndexedDocuments = async () => {
    try {
      const response = await fetch('/api/rag/documents');
      const data = await response.json();
      if (response.ok) {
        setIndexedDocs(data.documents || []);
      }
    } catch (error) {
      console.error('ë¬¸ì„œ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨:', error);
    }
  };

  const addMessage = (role: 'user' | 'assistant', content: string, sources?: Array<{ filename: string; chunkIndex: number }>) => {
    const newMessage: Message = {
      id: Date.now().toString(),
      role,
      content,
      sources,
      timestamp: new Date()
    };
    setMessages(prev => [...prev, newMessage]);
  };

  const handleSendMessage = async () => {
    if (!inputMessage.trim() || isLoading) return;

    if (!apiKey) {
      onApiKeyRequired();
      return;
    }

    const question = inputMessage.trim();
    setInputMessage('');
    addMessage('user', question);
    
    setIsLoading(true);
    try {
      const response = await fetch('/api/rag/ask', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question })
      });

      const data = await response.json();
      
      if (response.ok) {
        addMessage('assistant', data.answer, data.sources);
      } else {
        addMessage('assistant', `âŒ ì˜¤ë¥˜: ${data.error}`);
      }
    } catch (error) {
      console.error('ì§ˆë¬¸ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
      addMessage('assistant', 'âŒ ë‹µë³€ì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setIsLoading(false);
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-2xl h-[600px] flex flex-col">
        {/* í—¤ë” */}
        <div className="bg-gradient-to-r from-indigo-600 to-purple-600 text-white px-6 py-4 rounded-t-2xl flex items-center justify-between">
          <div className="flex items-center space-x-3">
            <MessageCircle className="w-6 h-6" />
            <div>
              <h2 className="text-lg font-semibold">ë§¤ë‰´ì–¼ ì±—ë´‡</h2>
              <p className="text-xs text-indigo-100">
                {indexedDocs.length > 0 
                  ? `${indexedDocs.length}ê°œ ë§¤ë‰´ì–¼ í•™ìŠµë¨` 
                  : 'ë§¤ë‰´ì–¼ì„ ì—…ë¡œë“œí•˜ê³  ì§ˆë¬¸í•˜ì„¸ìš”'}
              </p>
            </div>
          </div>
          <button
            onClick={onClose}
            className="hover:bg-white hover:bg-opacity-20 rounded-lg p-2 transition"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* ë©”ì‹œì§€ ì˜ì—­ */}
        <div className="flex-1 overflow-y-auto p-6 space-y-4 bg-gray-50">
          {messages.length === 0 ? (
            <div className="h-full flex items-center justify-center">
              <div className="text-center max-w-md">
                <MessageCircle className="w-16 h-16 mx-auto mb-4 text-gray-300" />
                <h3 className="text-lg font-semibold text-gray-700 mb-2">
                  ë§¤ë‰´ì–¼ì— ëŒ€í•´ ì§ˆë¬¸í•˜ì„¸ìš”
                </h3>
                <p className="text-sm text-gray-500">
                  ì—…ë¡œë“œëœ ë§¤ë‰´ì–¼ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ ì •í™•í•œ ë‹µë³€ì„ ì œê³µí•©ë‹ˆë‹¤
                </p>
                {indexedDocs.length > 0 && (
                  <div className="mt-4 space-y-1">
                    <p className="text-xs text-gray-400">í•™ìŠµëœ ë§¤ë‰´ì–¼:</p>
                    {indexedDocs.map((doc, idx) => (
                      <div key={idx} className="text-xs text-gray-600 flex items-center justify-center">
                        <FileText className="w-3 h-3 mr-1" />
                        {doc.filename}
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          ) : (
            messages.map((message) => (
              <div
                key={message.id}
                className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
              >
                <div
                  className={`max-w-[80%] rounded-2xl px-4 py-3 ${
                    message.role === 'user'
                      ? 'bg-indigo-600 text-white'
                      : 'bg-white shadow-sm border border-gray-200'
                  }`}
                >
                  <p className="whitespace-pre-wrap text-sm">{message.content}</p>
                  
                  {message.sources && message.sources.length > 0 && (
                    <div className="mt-2 pt-2 border-t border-gray-200">
                      <p className="text-xs text-gray-500 mb-1">ğŸ“š ì°¸ì¡° ì¶œì²˜:</p>
                      <div className="space-y-1">
                        {message.sources.map((source, idx) => (
                          <div key={idx} className="text-xs text-gray-600 flex items-start">
                            <span className="mr-1">â€¢</span>
                            <span>{source.filename}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            ))
          )}
          {isLoading && (
            <div className="flex justify-start">
              <div className="bg-white shadow-sm border border-gray-200 rounded-2xl px-4 py-3 flex items-center space-x-2">
                <Loader2 className="w-4 h-4 animate-spin text-indigo-600" />
                <span className="text-sm text-gray-600">ë‹µë³€ ìƒì„± ì¤‘...</span>
              </div>
            </div>
          )}
          <div ref={messagesEndRef} />
        </div>

        {/* ì…ë ¥ ì˜ì—­ */}
        <div className="border-t bg-white p-4 rounded-b-2xl">
          <div className="flex space-x-2">
            <textarea
              ref={inputRef}
              value={inputMessage}
              onChange={(e) => setInputMessage(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder={indexedDocs.length > 0 ? "ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”..." : "ë¨¼ì € ë§¤ë‰´ì–¼ì„ ì—…ë¡œë“œí•´ì£¼ì„¸ìš”"}
              rows={1}
              className="flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent resize-none text-sm"
              disabled={isLoading || indexedDocs.length === 0}
            />
            <button
              onClick={handleSendMessage}
              disabled={isLoading || !inputMessage.trim() || indexedDocs.length === 0}
              className="bg-indigo-600 text-white px-4 py-3 rounded-lg hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition flex items-center"
            >
              <Send className="w-5 h-5" />
            </button>
          </div>
          <p className="text-xs text-gray-500 mt-2 text-center">
            Shift + Enterë¡œ ì¤„ë°”ê¿ˆ â€¢ Enterë¡œ ì „ì†¡
          </p>
        </div>
      </div>
    </div>
  );
}
```

#### ğŸ“„ `client/src/components/FloatingChatButton.tsx` ìƒì„±

```typescript
import React from 'react';
import { MessageCircle } from 'lucide-react';

interface FloatingChatButtonProps {
  onClick: () => void;
  hasNewMessage?: boolean;
}

export default function FloatingChatButton({ onClick, hasNewMessage = false }: FloatingChatButtonProps) {
  return (
    <button
      onClick={onClick}
      className="fixed bottom-6 right-6 bg-gradient-to-r from-indigo-600 to-purple-600 text-white p-4 rounded-full shadow-2xl hover:shadow-3xl hover:scale-110 transition-all duration-300 z-40 group"
      aria-label="ì±—ë´‡ ì—´ê¸°"
    >
      <MessageCircle className="w-6 h-6" />
      {hasNewMessage && (
        <span className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 rounded-full border-2 border-white animate-pulse" />
      )}
      
      {/* íˆ´íŒ */}
      <div className="absolute bottom-full right-0 mb-2 px-3 py-2 bg-gray-800 text-white text-sm rounded-lg opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap pointer-events-none">
        ë§¤ë‰´ì–¼ ì±—ë´‡
        <div className="absolute top-full right-4 w-2 h-2 bg-gray-800 transform rotate-45 -mt-1" />
      </div>
    </button>
  );
}
```

#### ğŸ“„ `client/src/components/ApiKeySetupModal.tsx` ìƒì„±

```typescript
import React, { useState } from 'react';
import { Key, X, ExternalLink } from 'lucide-react';

interface ApiKeySetupModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: (apiKey: string) => void;
  currentApiKey?: string;
}

export default function ApiKeySetupModal({ isOpen, onClose, onSave, currentApiKey = '' }: ApiKeySetupModalProps) {
  const [apiKey, setApiKey] = useState(currentApiKey);
  const [isLoading, setIsLoading] = useState(false);

  const handleSave = async () => {
    if (!apiKey.trim()) {
      alert('API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.');
      return;
    }

    setIsLoading(true);
    try {
      const response = await fetch('/api/rag/setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ apiKey: apiKey.trim() })
      });

      if (response.ok) {
        onSave(apiKey.trim());
        onClose();
      } else {
        const data = await response.json();
        alert(data.error || 'API í‚¤ ì„¤ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
      }
    } catch (error) {
      console.error('API í‚¤ ì„¤ì • ì˜¤ë¥˜:', error);
      alert('API í‚¤ ì„¤ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
    } finally {
      setIsLoading(false);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-2xl shadow-2xl p-6 max-w-md w-full">
        <div className="flex items-center justify-between mb-4">
          <div className="flex items-center space-x-2">
            <div className="bg-indigo-100 p-2 rounded-lg">
              <Key className="w-5 h-5 text-indigo-600" />
            </div>
            <h2 className="text-xl font-bold text-gray-800">Gemini API ì„¤ì •</h2>
          </div>
          <button
            onClick={onClose}
            className="hover:bg-gray-100 rounded-lg p-2 transition"
          >
            <X className="w-5 h-5 text-gray-600" />
          </button>
        </div>

        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              API í‚¤
            </label>
            <input
              type="password"
              value={apiKey}
              onChange={(e) => setApiKey(e.target.value)}
              placeholder="AIzaSy..."
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
              onKeyPress={(e) => e.key === 'Enter' && handleSave()}
            />
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
            <p className="text-sm text-blue-800 mb-2">
              ğŸ”‘ Gemini API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤
            </p>
            <a
              href="https://makersuite.google.com/app/apikey"
              target="_blank"
              rel="noopener noreferrer"
              className="text-sm text-blue-600 hover:text-blue-700 flex items-center"
            >
              API í‚¤ ë°œê¸‰ë°›ê¸°
              <ExternalLink className="w-3 h-3 ml-1" />
            </a>
          </div>

          <div className="flex space-x-2">
            <button
              onClick={onClose}
              className="flex-1 px-4 py-3 border border-gray-300 rounded-lg hover:bg-gray-50 transition font-medium text-gray-700"
            >
              ì·¨ì†Œ
            </button>
            <button
              onClick={handleSave}
              disabled={isLoading}
              className="flex-1 bg-indigo-600 text-white px-4 py-3 rounded-lg hover:bg-indigo-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition font-medium"
            >
              {isLoading ? 'ì €ì¥ ì¤‘...' : 'ì €ì¥'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

### STEP 5: ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜ì´ì§€ì— í†µí•©

#### ğŸ“ ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì»´í¬ë„ŒíŠ¸ ìˆ˜ì •

íŒŒì¼ ìœ„ì¹˜: `client/src/pages/ManualLibrary.tsx` (ë˜ëŠ” ì‹¤ì œ ê²½ë¡œì— ë§ê²Œ)

```typescript
import React, { useState, useEffect } from 'react';
import FloatingChatButton from '../components/FloatingChatButton';
import ChatbotModal from '../components/ChatbotModal';
import ApiKeySetupModal from '../components/ApiKeySetupModal';

export default function ManualLibrary() {
  const [isChatOpen, setIsChatOpen] = useState(false);
  const [isApiKeyModalOpen, setIsApiKeyModalOpen] = useState(false);
  const [apiKey, setApiKey] = useState('');
  
  // ê¸°ì¡´ ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ ìƒíƒœë“¤...
  const [manuals, setManuals] = useState([]);

  // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ API í‚¤ ë¡œë“œ
  useEffect(() => {
    const savedApiKey = localStorage.getItem('gemini_api_key');
    if (savedApiKey) {
      setApiKey(savedApiKey);
      // ì„œë²„ì— API í‚¤ ì„¤ì •
      fetch('/api/rag/setup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ apiKey: savedApiKey })
      });
    }
  }, []);

  // ë§¤ë‰´ì–¼ ì—…ë¡œë“œ ì‹œ RAG ì‹œìŠ¤í…œì—ë„ ì¸ë±ì‹±
  const handleManualUpload = async (file: File) => {
    // ê¸°ì¡´ ì—…ë¡œë“œ ë¡œì§...
    // íŒŒì¼ì´ ì„œë²„ì— ì €ì¥ëœ í›„:
    
    const uploadedFilePath = `/path/to/uploaded/${file.name}`; // ì‹¤ì œ ì—…ë¡œë“œëœ íŒŒì¼ ê²½ë¡œ
    
    // RAG ì‹œìŠ¤í…œì— ì¸ë±ì‹±
    if (apiKey) {
      try {
        await fetch('/api/rag/index-existing', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            filePath: uploadedFilePath,
            filename: file.name
          })
        });
      } catch (error) {
        console.error('RAG ì¸ë±ì‹± ì˜¤ë¥˜:', error);
      }
    }
  };

  const handleApiKeySave = (newApiKey: string) => {
    setApiKey(newApiKey);
    localStorage.setItem('gemini_api_key', newApiKey);
  };

  const handleOpenChat = () => {
    if (!apiKey) {
      setIsApiKeyModalOpen(true);
    } else {
      setIsChatOpen(true);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* ê¸°ì¡´ ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ UI... */}
      <div className="container mx-auto p-6">
        <h1 className="text-3xl font-bold mb-6">ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬</h1>
        
        {/* ë§¤ë‰´ì–¼ ëª©ë¡... */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {manuals.map((manual, idx) => (
            <div key={idx} className="bg-white p-4 rounded-lg shadow">
              {/* ë§¤ë‰´ì–¼ ì¹´ë“œ ë‚´ìš©... */}
            </div>
          ))}
        </div>
      </div>

      {/* í”Œë¡œíŒ… ì±—ë´‡ ë²„íŠ¼ */}
      <FloatingChatButton onClick={handleOpenChat} />

      {/* ì±—ë´‡ ëª¨ë‹¬ */}
      <ChatbotModal
        isOpen={isChatOpen}
        onClose={() => setIsChatOpen(false)}
        apiKey={apiKey}
        onApiKeyRequired={() => {
          setIsChatOpen(false);
          setIsApiKeyModalOpen(true);
        }}
      />

      {/* API í‚¤ ì„¤ì • ëª¨ë‹¬ */}
      <ApiKeySetupModal
        isOpen={isApiKeyModalOpen}
        onClose={() => setIsApiKeyModalOpen(false)}
        onSave={handleApiKeySave}
        currentApiKey={apiKey}
      />
    </div>
  );
}
```

---

### STEP 6: í™˜ê²½ ì„¤ì •

#### ğŸ“„ `.env` íŒŒì¼ì— ì¶”ê°€ (ì„ íƒì‚¬í•­)

```bash
# Gemini API (ì„ íƒì‚¬í•­ - UIì—ì„œ ì…ë ¥ ê°€ëŠ¥)
GEMINI_API_KEY=your_api_key_here

# íŒŒì¼ ì—…ë¡œë“œ ì„¤ì •
MAX_FILE_SIZE=52428800
UPLOAD_DIR=./uploads/manuals
```

---

## ğŸš€ ì‹¤í–‰ ë° í…ŒìŠ¤íŠ¸

### 1. ê°œë°œ ì„œë²„ ì‹¤í–‰

```bash
npm run dev
```

### 2. í…ŒìŠ¤íŠ¸ ìˆœì„œ

1. âœ… ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜ì´ì§€ ì ‘ì†
2. âœ… ì˜¤ë¥¸ìª½ í•˜ë‹¨ ì±—ë´‡ ì•„ì´ì½˜ í™•ì¸
3. âœ… ì±—ë´‡ ì•„ì´ì½˜ í´ë¦­
4. âœ… API í‚¤ ì„¤ì • ëª¨ë‹¬ì—ì„œ Gemini API í‚¤ ì…ë ¥
5. âœ… ë§¤ë‰´ì–¼ íŒŒì¼(PDF/Word) ì—…ë¡œë“œ
6. âœ… ì±—ë´‡ì—ì„œ ì§ˆë¬¸í•˜ê¸°
7. âœ… ë‹µë³€ ë° ì¶œì²˜ í™•ì¸

---

## ğŸ“Š ì£¼ìš” ê¸°ëŠ¥

### âœ… êµ¬í˜„ëœ ê¸°ëŠ¥

1. **ìë™ ë§¤ë‰´ì–¼ í•™ìŠµ**: ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì—…ë¡œë“œëœ ë§¤ë‰´ì–¼ ìë™ ì¸ë±ì‹±
2. **í”Œë¡œíŒ… ì±—ë´‡**: ì˜¤ë¥¸ìª½ í•˜ë‹¨ ê³ ì • ìœ„ì¹˜
3. **ëª¨ë‹¬ ì¸í„°í˜ì´ìŠ¤**: íŒì—… í˜•íƒœì˜ ì±„íŒ…ì°½
4. **RAG ê²€ìƒ‰**: ì½”ì‚¬ì¸ ìœ ì‚¬ë„ ê¸°ë°˜ ì˜ë¯¸ë¡ ì  ê²€ìƒ‰
5. **ì¶œì²˜ í‘œì‹œ**: ë‹µë³€ì˜ ê·¼ê±°ê°€ ëœ ë§¤ë‰´ì–¼ í‘œì‹œ
6. **API í‚¤ ê´€ë¦¬**: ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì €ì¥ ë° ê´€ë¦¬
7. **PDF/Word ì§€ì›**: ë‹¤ì–‘í•œ í˜•ì‹ì˜ ë§¤ë‰´ì–¼ ì²˜ë¦¬

---

## ğŸ’¡ ì»¤ìŠ¤í„°ë§ˆì´ì§• íŒ

### ì±—ë´‡ ìœ„ì¹˜ ë³€ê²½

```typescript
// FloatingChatButton.tsx
className="fixed bottom-6 right-6 ..." // ì›í•˜ëŠ” ìœ„ì¹˜ë¡œ ë³€ê²½
```

### ì±—ë´‡ ìƒ‰ìƒ ë³€ê²½

```typescript
// indigo-600 â†’ ì›í•˜ëŠ” ìƒ‰ìƒìœ¼ë¡œ ì¼ê´„ ë³€ê²½
// ì˜ˆ: blue-600, purple-600, green-600 ë“±
```

### ì²­í¬ í¬ê¸° ì¡°ì • (ë¹„ìš© ì ˆê°)

```typescript
// server/services/ragService.ts
function chunkText(text: string, chunkSize: number = 2000, overlap: number = 300)
```

---

## ğŸ› ë¬¸ì œ í•´ê²°

### "RAG ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
â†’ API í‚¤ ì„¤ì • í™•ì¸

### PDF í…ìŠ¤íŠ¸ê°€ ì¶”ì¶œë˜ì§€ ì•ŠìŒ
â†’ ìŠ¤ìº”ëœ PDFì˜ ê²½ìš° OCR í•„ìš” (í–¥í›„ ì—…ë°ì´íŠ¸)

### "Rate limit exceeded"
â†’ Gemini API ë¬´ë£Œ í• ë‹¹ëŸ‰ í™•ì¸ (ë¶„ë‹¹ 15 ìš”ì²­)

---

## ğŸ“ ì²´í¬ë¦¬ìŠ¤íŠ¸

- [ ] íŒ¨í‚¤ì§€ ì„¤ì¹˜ ì™„ë£Œ
- [ ] ì„œë²„ íŒŒì¼ ìƒì„± (`ragService.ts`, `routes/rag.ts`)
- [ ] ì„œë²„ ë¼ìš°íŠ¸ ì¶”ê°€ (`server/index.ts`)
- [ ] í´ë¼ì´ì–¸íŠ¸ ì»´í¬ë„ŒíŠ¸ ìƒì„± (3ê°œ íŒŒì¼)
- [ ] ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ í˜ì´ì§€ í†µí•©
- [ ] Gemini API í‚¤ ë°œê¸‰
- [ ] ê°œë°œ ì„œë²„ ì‹¤í–‰ ë° í…ŒìŠ¤íŠ¸

---

**ì´ ê°€ì´ë“œëŒ€ë¡œ êµ¬í˜„í•˜ë©´ ì™„ë²½í•˜ê²Œ ì‘ë™í•˜ëŠ” RAG ì±—ë´‡ì´ ë§¤ë‰´ì–¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— í†µí•©ë©ë‹ˆë‹¤!** ğŸ‰